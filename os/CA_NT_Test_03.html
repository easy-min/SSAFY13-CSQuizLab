<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>네트워크 응용계층 CS 스터디 객관식 문제 - 난이도 조정</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&amp;display=swap" rel="stylesheet">
  <style>
    /* 전체 배경과 폰트 설정 */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f8f9fa;
    }
    /* 퀴즈 컨테이너 */
    .quiz-container {
      max-width: 800px;
      margin: 40px auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 {
      margin-bottom: 30px;
      font-weight: 700;
      font-size: 1.5rem;
      color: #212529;
    }
    /* 이름 입력 */
    label[for="userName"] { font-weight: 600; }
    #userName {
      padding: 8px 12px;
      font-size: 1rem;
      border: 1px solid #ced4da;
      border-radius: 4px;
      margin-top: 5px;
    }
    /* 문제 및 옵션 스타일 */
    .question {
      margin: 24px 0 10px;
      font-weight: 600;
      font-size: 1rem;
      color: #343a40;
    }
    .options { margin-bottom: 20px; line-height: 1.6; }
    .options label { cursor: pointer; }
    .options input[type="radio"] { margin-right: 8px; }
    /* 제출 버튼 */
    button {
      margin-top: 10px;
      padding: 12px 20px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
      background-color: #0064ff;
      color: #fff;
      font-weight: 600;
    }
    button:hover { background-color: #0052cc; }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    /* 결과 영역 */
    #result { margin-top: 20px; }
    #submissionTime h3, #score h2 {
      margin-top: 20px;
      font-weight: 600;
      color: #212529;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background-color: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    th, td {
      text-align: center;
      padding: 12px;
      border-bottom: 1px solid #eee;
      font-size: 0.95rem;
    }
    th { background-color: #f1f3f5; font-weight: 600; }
    tr:last-child td { border-bottom: none; }
    .correct { color: #28a745; }
    .incorrect { color: #dc3545; }
    /* 해설 영역 */
    #explanation {
      font-size: 0.95rem;
      line-height: 1.6;
      color: #333;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    #explanation h3 { margin-top: 0; font-size: 1rem; font-weight: 700; }
    #explanation ul { margin-left: 1.2rem; margin-top: 10px; }
    #explanation li { margin-bottom: 8px; }
    /* 해설 다운로드 버튼 */
    #downloadExplanation {
      display: none;
      margin-top: 10px;
      padding: 10px 16px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #91a743;
      color: #fff;
      transition: background-color 0.3s;
    }
    #downloadExplanation:hover { background-color: #7d9435; }
    @media (max-width: 600px) {
      .quiz-container { margin: 20px auto; padding: 20px; }
      h1 { font-size: 1.25rem; }
      button { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="quiz-container">
    <h1>네트워크 응용계층 CS 스터디 객관식 문제 - 기말고사</h1>
    <form id="quizForm">
      <label for="userName"><b>이름 입력:</b></label><br>
      <input type="text" id="userName" placeholder="이름을 입력하세요" required=""><br><br>
      <div id="quizQuestions"></div>
      <button type="button" id="submitButton" onclick="checkAnswers()">제출하기</button>
    </form>
    <div id="result"></div>
    <div id="submissionTime"></div>
    <div id="score"></div>
    <div id="explanation"></div>
    <button type="button" id="downloadExplanation" onclick="downloadExplanation()">해설 다운로드</button>
  </div>

  <script>
    /* 
      아래 quizData 배열에는 20개의 기말고사 수준 문제를 포함합니다.
      각 문제는 원본 내용을 유지하되, 학술적이고 난이도 높은 표현으로 변형했습니다.
    */
    const quizData = [
      {
        question: "1. DNS 캐싱 메커니즘의 운용 원리와 TTL의 역할을 고찰할 때, 다음 중 전산 네트워크의 효율 및 부하 분산 관점에서 올바른 서술은?",
        options: [
          "TTL에 따라 캐시된 레코드를 유지하며, TTL은 도메인 관리자가 지정하는 값으로 부하와 갱신 주기를 조절한다.",
          "캐싱은 전적으로 로컬 네임 서버에서만 이루어지며, 클라이언트는 캐시를 사용하지 않는다.",
          "한 번 캐시된 정보는 TTL에 관계없이 영구적이며 갱신되지 않는다.",
          "TTL은 패킷의 최대 홉 수를 의미, 0이 되면 캐시가 폐기된다.",
          "DNS 캐싱은 hosts 파일과 동일하게 작동하여 재부팅 시 초기화된다."
        ],
        answer: "1",
        explanation: "TTL은 캐시의 유효 기간을 결정하며, 관리자의 설정에 따라 네임 서버 부하 및 갱신 빈도가 달라집니다."
      },
      {
        question: "2. DNS 네임 리졸빙 과정에 있어, 질의 방식의 구동 원리와 부하 분산 효과를 고려할 때, 가장 적합한 설명은?",
        options: [
          "재귀적 질의는 로컬 네임 서버가 다단계 질의를 수행해 최종 응답을 반환함으로써 클라이언트 부담을 줄인다.",
          "반복적 질의는 클라이언트가 각 네임 서버와 직접 연결하여 순차적으로 질의한다.",
          "두 질의 방식은 기술적 차이는 없으며 동일한 결과를 도출한다.",
          "DNS는 항상 재귀와 반복을 혼합 사용한다.",
          "반복적 질의는 매 단계마다 다음 대상 정보를 누적하여 최종 응답을 구성한다."
        ],
        answer: "1",
        explanation: "재귀적 질의는 표준 DNS 운용 방식으로, 로컬 네임 서버가 모든 하위 질의를 처리해 클라이언트에 최종 응답을 전달합니다."
      },
      {
        question: "3. URL의 구성 요소 및 문법을 고찰할 때, 다음 중 웹 자원 식별 표준에 부합하는 정확한 설명은?",
        options: [
          "URL은 ‘scheme, authority, path, query, fragment’로 구성되며, 예시 URL에서는 authority가 호스트명과 포트 번호를 포함한다.",
          "URL의 scheme은 HTTP 및 HTTPS만 허용된다.",
          "authority는 반드시 숫자 IP 주소 형식을 취해야 한다.",
          "fragment는 요청 처리에 직접 영향을 미친다.",
          "query는 항상 암호화되어야 한다."
        ],
        answer: "1",
        explanation: "URL은 정해진 구성 요소를 가지며, authority는 호스트명과 포트 정보를 포함하는 것이 표준입니다."
      },
      {
        question: "4. HTTP의 무상태(stateless) 특성이 네트워크 설계에 미치는 영향을 평가할 때, 다음 중 올바르게 설명된 것은?",
        options: [
          "HTTP는 상태 정보를 유지하지 않기 때문에, 세션 관리 등을 위해 추가적인 쿠키나 세션 관리 기법이 필요하다.",
          "무상태성은 클라이언트가 서버 상태를 추적할 수 없게 하여 통신 효율을 저하시킨다.",
          "무상태성으로 인해 연속 데이터 전송이나 스트리밍에 부적합하다.",
          "모든 클라이언트 상태를 서버가 저장해야 하므로 자원 소모가 증가한다.",
          "무상태성은 암호화된 요청에만 적용된다."
        ],
        answer: "1",
        explanation: "HTTP는 요청 간 상태 정보를 유지하지 않으므로, 상태 기반 기능은 쿠키나 세션 등 외부 기법으로 보완해야 합니다."
      },
      {
        question: "5. HTTP 메서드 PUT과 PATCH의 기능적 차이를 평가할 때, 웹 자원 수정에 관한 실제 운용 원칙과 가장 일치하는 설명은?",
        options: [
          "PUT은 대상 URI의 전체 자원을 대체하거나 새로 생성하며, PATCH는 부분 수정에 사용된다.",
          "PUT은 자원 생성 전용, PATCH는 수정 전용이다.",
          "PUT은 멱등성이 보장되나 PATCH는 그렇지 않다.",
          "PUT은 구형 프로토콜이고, PATCH는 최신 표준이다.",
          "PUT은 인증 조건 하에서만 작동된다."
        ],
        answer: "1",
        explanation: "PUT은 전체 자원 처리, PATCH는 부분 수정에 최적화되어 데이터 전송량을 줄이는 효과가 있습니다."
      },
      {
        question: "6. HTTP 상태 코드 체계를 분석할 때, 다음 중 분류 및 의미 설명과 상반되는 부적절한 서술은?",
        options: [
          "100번대는 정보 제공을 목적으로 하며, 예로 100(Continue)와 101(Switching Protocols)이 있다.",
          "200번대는 성공적 처리 결과를 의미하고, 204(No Content)는 데이터 없음으로 해석된다.",
          "300번대는 리다이렉션을 나타내며, 301은 영구 이동을 의미한다.",
          "400번대는 클라이언트 오류를 나타내고, 401과 403은 각각 인증 및 권한 문제를 시사한다.",
          "500번대는 서버 오류를 나타내며, 503은 접근 권한 문제를 의미한다."
        ],
        answer: "5",
        explanation: "503은 서버 과부하나 유지보수로 인한 일시적 중단을 의미하므로, 접근 권한 문제와는 관련이 없습니다."
      },
      {
        question: "7. HTTP 인증 메커니즘에서 WWW-Authenticate와 Authorization 헤더의 역할을 논할 때, 다음 중 가장 적절한 설명은?",
        options: [
          "WWW-Authenticate는 401 응답 시 인증 방식을 안내하고, Authorization은 해당 인증 정보를 전송하는 데 사용된다.",
          "Authorization은 접근 권한 부여를 나타내며, WWW-Authenticate는 인증 정보 요청용이다.",
          "두 헤더는 HTTP/2에서 도입되어 HTTP/1.1에서는 사용되지 않는다.",
          "WWW-Authenticate는 토큰 인증 전용이며, Authorization은 모든 방식에 공통적이다.",
          "두 헤더는 HTTPS에서만 유효하다."
        ],
        answer: "1",
        explanation: "WWW-Authenticate는 401 응답과 함께 인증 방법을 제시하고, 클라이언트는 이를 참고하여 Authorization 헤더에 인증 정보를 포함시킵니다."
      },
      {
        question: "8. HTTP 통신에서 지속 연결과 비지속 연결의 운영 방식 차이에 대해, 다음 중 학문적 정의에 가장 부합하는 설명은?",
        options: [
          "비지속 연결은 각 요청마다 별도의 TCP 연결을 수립하는 반면, 지속 연결은 단일 TCP 연결로 연속 요청을 처리한다.",
          "지속 연결은 HTTP/1.0 전용이고, HTTP/1.1은 비지속 연결이다.",
          "두 방식의 차이는 단지 연결 유지 시간에 불과하다.",
          "비지속 연결은 TCP 없이 즉시 데이터를 주고받으며, 지속 연결은 TCP 연결 후 통신한다.",
          "연결 선택은 클라이언트에 전적으로 의존한다."
        ],
        answer: "1",
        explanation: "HTTP/1.1부터 지속 연결(keep-alive)을 사용하여 하나의 TCP 연결로 다수의 요청-응답을 처리하여 오버헤드를 줄입니다."
      },
      {
        question: "9. HTTP 캐시 검증에서 조건부 요청의 원리를 논할 때, 다음 중 가장 적절한 서술은?",
        options: [
          "If-Modified-Since와 If-None-Match 헤더를 사용하여 캐시 유효성을 검사하고, 변경이 없으면 304 응답을 유도한다.",
          "조건부 요청은 HTTP/2 전용으로, 구 버전에서는 사용되지 않는다.",
          "특정 조건 만족 시에만 요청 처리하는 보안 메커니즘이다.",
          "Range 헤더와 결합하여 부분 다운로드를 수행한다.",
          "HTTPS 환경에서만 작동한다."
        ],
        answer: "1",
        explanation: "조건부 요청은 If-Modified-Since/If-None-Match를 통해 캐시의 유효성을 확인하고, 변경이 없으면 304로 응답하여 불필요한 데이터 전송을 줄입니다."
      },
      {
        question: "10. 세션 인증 체계에서 쿠키의 역할에 대해 고찰할 때, 다음 중 가장 정확한 서술은?",
        options: [
          "서버가 클라이언트 인증 후 고유 세션 ID를 생성, 쿠키로 전달하며 이후 요청 시 이를 확인해 사용자 인증을 수행한다.",
          "세션 인증은 쿠키 없이 HTTP Authorization 헤더로 이루어진다.",
          "클라이언트가 암호화된 인증 정보를 쿠키에 저장하고, 서버는 이를 복호화한다.",
          "세션 인증과 쿠키는 완전히 독립된 메커니즘이다.",
          "클라이언트가 전담하여 인증 로직을 처리하며, 쿠키는 단순 정보 전달에 불과하다."
        ],
        answer: "1",
        explanation: "일반적인 세션 인증 방식은 서버가 세션 ID를 생성하여 쿠키로 전달하고, 이후 요청 시 해당 ID로 클라이언트를 인증하는 것입니다."
      },
      {
        question: "11. URI, URL, URN의 관계 및 차이를 개념적으로 분석할 때, 다음 중 올바른 설명은?",
        options: [
          "URI는 자원 식별의 상위 개념이며, URL과 URN은 각각 자원의 위치와 이름에 기반한 하위 표현 방식이다.",
          "세 용어는 동일한 의미를 가진다.",
          "URI는 프로토콜 종속, URL은 독립, URN은 네임스페이스 한정이다.",
          "URL과 URN은 결합형 하이브리드 형태이다.",
          "URI는 HTTP 전용이다."
        ],
        answer: "1",
        explanation: "URI는 자원을 식별하는 포괄적 용어이며, URL과 URN은 각각 위치와 이름을 통한 식별 방법을 의미합니다."
      },
      {
        question: "12. HTTP에서 미디어 타입(MIME 타입)의 구조와 역할을 평가할 때, 다음 중 가장 적절한 설명은?",
        options: [
          "미디어 타입은 ‘타입/서브타입’ 형식으로 Content-Type 헤더에 명시되어 메시지 본문의 데이터 형식을 정의한다.",
          "HTML의 <meta> 태그로만 지정된다.",
          "HTTP/2 도입 후 개선되었고, 이전에는 Content-Format 헤더를 사용했다.",
          "Accept-Type 헤더로 서버 전송 가능 목록을 제한한다.",
          "Content-Encoding과 함께 응답 압축을 지정한다."
        ],
        answer: "1",
        explanation: "미디어 타입은 '타입/서브타입'으로 지정되어 클라이언트와 서버가 데이터 형식을 이해하도록 돕습니다."
      },
      {
        question: "13. 도메인 네임의 계층 구조를 분석할 때, 다음 중 학문적 정의에 가장 부합하는 설명은?",
        options: [
          "도메인 네임은 점(.)으로 구분된 계층 구조로, 오른쪽(루트)부터 왼쪽(세부 도메인)으로 읽히며, 각 계층은 TLD, 2단계, 3단계 등의 역할을 수행한다.",
          "항상 4개 이상의 레벨을 필요로 한다.",
          "가장 왼쪽이 루트이다.",
          "계층은 단순 가독성 목적으로만 존재한다.",
          "IP 주소 옥텟과 직접 매핑된다."
        ],
        answer: "1",
        explanation: "도메인 네임은 계층적 구조를 이루며, 각 레벨은 특정 역할(예: TLD, 2단계 등)을 담당합니다."
      },
      {
        question: "14. 로컬 hosts 파일과 DNS 시스템의 기능적 차이를 평가할 때, 다음 중 올바른 설명은?",
        options: [
          "hosts 파일은 로컬 매핑 테이블로서 우선 참조되며, DNS는 분산 글로벌 네임 서버를 통해 추가 해석을 수행한다.",
          "hosts 파일은 브라우저 캐시 전용이고, DNS는 OS 서비스이다.",
          "hosts 파일은 원격에서 관리되며, DNS는 로컬에서 설정된다.",
          "hosts는 로컬, DNS는 전용 인터넷 서비스이다.",
          "hosts는 IPv4만 지원되고, DNS는 IPv4/IPv6 모두 지원한다."
        ],
        answer: "1",
        explanation: "hosts 파일은 로컬에 저장된 매핑 정보를 제공하고, DNS는 전 세계 네임 서버를 활용하여 도메인 해석을 수행합니다."
      },
      {
        question: "15. 시스템 가용성 향상을 위해 99.9%에서 99.999%로 개선할 때, 다음 중 가장 효과적이지 않은 전략은 무엇인가?",
        options: [
          "네트워크 카드 이중화로 단일 장애 제거",
          "핵심 서버 Active/Standby 이중화",
          "로드 밸런서 도입으로 트래픽 분산",
          "하드웨어 성능 개선을 통한 처리 속도 향상",
          "기존 네트워크 단일 장애점 식별 후 이중화"
        ],
        answer: "4",
        explanation: "하드웨어 성능 향상은 서비스 응답 속도를 개선하지만, 가용성 측면에서는 장애 대응 및 이중화 전략에 비해 직접적 효과가 낮습니다."
      },
      {
        question: "16. 대규모 전자상거래 환경에서 사용자 세션 고정과 서버 성능 차이를 고려할 때, 가장 적합한 로드 밸런싱 알고리즘은 무엇인가?",
        options: [
          "단순 라운드 로빈",
          "최소 연결 방식",
          "무작위 선택",
          "IP 해시 기반 및 가중치 조합",
          "응답 시간 기반"
        ],
        answer: "4",
        explanation: "IP 해시와 가중치 조합 방식은 사용자의 세션 고정을 유지하면서 서버의 처리 능력 차이를 반영할 수 있습니다."
      },
      {
        question: "17. 프록시 서버 설계 시, 포워드와 리버스 프록시의 기능적 차이를 고려할 때, 다음 중 실제 운용 원칙에 반하는 설명은 무엇인가?",
        options: [
          "포워드 프록시는 클라이언트 요청 대행 및 익명성 보장을 수행한다.",
          "리버스 프록시는 외부 요청을 내부 서버로 분산하여 부하를 완화한다.",
          "포워드 프록시는 내부 콘텐츠 필터링 및 접근 제어에 활용될 수 있다.",
          "리버스 프록시는 SSL 종료, 캐싱, 부하 분산 등의 기능을 제공한다.",
          "포워드 프록시는 오리진 서버 보호 역할을 수행하며, 리버스 프록시는 클라이언트 접근 제어를 주도한다."
        ],
        answer: "5",
        explanation: "실제 운용에서는 포워드 프록시가 클라이언트 요청의 대행 및 익명성 보장을, 리버스 프록시는 오리진 서버 보호와 부하 분산을 담당합니다. 5번은 역할을 혼동한 서술입니다."
      },
      {
        question: "18. 금융 서비스 환경에서 고객과 서버 간의 안전한 통신을 보장하기 위한 암호화 솔루션을 논할 때, 다음 중 데이터 무결성과 기밀성, 서버 인증, 그리고 고성능을 동시에 만족하는 것은?",
        options: [
          "대칭키 암호화 단독 (인증서 미사용, HTTP)",
          "비대칭키 단독 방식",
          "TLS: 초기 비대칭 핸드셰이크 후 대칭키 암호화",
          "서버 및 클라이언트의 직접 키 교환",
          "해시 기반 무결성 검증만"
        ],
        answer: "3",
        explanation: "TLS는 초기 비대칭키 교환을 통해 보안 연결을 확립한 후, 대칭키 암호화를 사용하여 성능과 보안을 동시에 제공합니다."
      },
      {
        question: "19. 무선 LAN 환경에서 모든 액세스 포인트가 2.4GHz 채널 6을 사용하여 간섭이 발생할 경우, 학문적 원칙에 따른 최적의 해결책은 무엇인가?",
        options: [
          "모든 AP의 전파 출력을 최대로 증폭",
          "인접 AP에 대해 상이한 채널(예: 1, 6, 11) 할당",
          "클라이언트 무선 모듈 업그레이드",
          "추가 AP 설치를 통한 커버리지 확대",
          "전 부문을 5GHz 대역으로 전환"
        ],
        answer: "2",
        explanation: "채널 간섭 문제는 각 AP에 비간섭 채널을 할당함으로써 해결할 수 있습니다."
      },
      {
        question: "20. 대형 온라인 서비스 제공업체의 네트워크 구성(웹 서버 3대, DB 1대, 인증 서버 1대, 외부 회선 1회선, 내부 관리용 무선 네트워크)을 고려할 때, 99.999% 가용성 달성을 위한 개선 방안 중 우선순위가 가장 낮은 것은?",
        options: [
          "DB 서버 이중화 (마스터-슬레이브 및 복제)",
          "인증 서버 이중화 (Active/Standby)",
          "중복 인터넷 회선 도입 (별도 ISP)",
          "내부 무선 LAN AP 이중화 및 채널 재구성",
          "로드 밸런서 이중화 및 자동 장애 조치 구축"
        ],
        answer: "4",
        explanation: "내부 관리용 무선 LAN AP 개선은 고객에게 직접 영향을 미치는 핵심 인프라 개선에 비해 우선순위가 낮습니다."
      }
    ];

    // 문제를 동적으로 생성하는 함수
    window.onload = function() {
      const quizDiv = document.getElementById("quizQuestions");
      let html = "";
      quizData.forEach((item, index) => {
        const qNum = index + 1;
        html += `<div class="question">${qNum}. ${item.question}</div><div class="options">`;
        item.options.forEach((option, idx) => {
          const optionNum = idx + 1;
          const mark = optionNum === 1 ? "①" : 
                       optionNum === 2 ? "②" : 
                       optionNum === 3 ? "③" : 
                       optionNum === 4 ? "④" : "⑤";
          html += `<label><input type="radio" name="q${qNum}" value="${optionNum}"> ${mark} ${option}</label><br>`;
        });
        html += `</div>`;
      });
      quizDiv.innerHTML = html;
    };

    // 채점 및 해설 출력 함수
    function checkAnswers() {
      const submitButton = document.getElementById("submitButton");
      if (submitButton.disabled) return;
      submitButton.disabled = true;

      const userName = document.getElementById("userName").value.trim();
      if (!userName) {
        alert("이름을 입력하세요!");
        submitButton.disabled = false;
        return;
      }

      let correctCount = 0;
      let explanationHTML = `<h3>${userName}님, 틀린 문제 해설</h3><ul>`;
      let explanationMD = `## ${userName}님, 틀린 문제 해설\n\n`;
      let resultTable = `<table>
                            <tr>
                              <th>문제 번호</th>
                              <th>제출한 답</th>
                              <th>정답</th>
                            </tr>`;

      quizData.forEach((item, index) => {
        const qNum = index + 1;
        const userAnswerElem = document.querySelector(`input[name="q${qNum}"]:checked`);
        const userAnswer = userAnswerElem ? userAnswerElem.value : "미선택";
        const correct = item.answer;
        const rowClass = (userAnswer === correct) ? "correct" : "incorrect";

        resultTable += `<tr class="${rowClass}">
                          <td>${qNum}</td>
                          <td>${userAnswer}</td>
                          <td>${correct}</td>
                        </tr>`;

        if (userAnswer === correct) {
          correctCount++;
        } else {
          explanationHTML += `<li><strong>문제 ${qNum}:</strong> ${item.explanation}</li>`;
          explanationMD += `- **문제 ${qNum}**: ${item.explanation}\n\n`;
        }
      });

      resultTable += `</table>`;
      document.getElementById("result").innerHTML = resultTable;
      const now = new Date();
      document.getElementById("submissionTime").innerHTML = `<h3>제출 시간: ${now.toLocaleTimeString()}</h3>`;
      document.getElementById("score").innerHTML = `<h2>${userName}님, 당신의 점수는 ${correctCount} / ${quizData.length}입니다.</h2>`;
      explanationHTML += "</ul>";

      if (correctCount < quizData.length) {
        document.getElementById("explanation").innerHTML = explanationHTML;
        const downloadBtn = document.getElementById("downloadExplanation");
        downloadBtn.style.display = "inline-block";
        downloadBtn.setAttribute("data-explanation", explanationMD);
      } else {
        document.getElementById("explanation").innerHTML = "<h3>모든 문제를 맞추셨습니다! 🎉</h3>";
      }
    }

    // 해설 다운로드 함수 (Markdown 파일로 저장)
    function downloadExplanation() {
      const explanationContent = document.getElementById("downloadExplanation").getAttribute("data-explanation");
      const blob = new Blob([explanationContent], { type: "text/markdown" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "네트워크_응용계층_CS_스터디_문제_틀린해설.md";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>
</body>
</html>
