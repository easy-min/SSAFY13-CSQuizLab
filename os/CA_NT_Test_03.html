<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>네트워크 응용계층 CS 스터디 객관식 문제</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
    rel="stylesheet"
  />
  <style>
    /* 전체 배경과 폰트 설정 */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f8f9fa;
    }

    /* 퀴즈 컨테이너 */
    .quiz-container {
      max-width: 800px;
      margin: 40px auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 30px;
    }

    h1 {
      margin-bottom: 30px;
      font-weight: 700;
      font-size: 1.5rem;
      color: #212529;
    }

    /* 이름 입력 */
    label[for="userName"] {
      font-weight: 600;
    }
    #userName {
      padding: 8px 12px;
      font-size: 1rem;
      border: 1px solid #ced4da;
      border-radius: 4px;
      margin-top: 5px;
    }

    /* 문제 및 옵션 스타일 */
    .question {
      margin: 24px 0 10px;
      font-weight: 600;
      font-size: 1rem;
      color: #343a40;
    }
    .options {
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .options label {
      cursor: pointer;
    }
    .options input[type="radio"] {
      margin-right: 8px;
    }

    /* 제출 버튼 */
    button {
      margin-top: 10px;
      padding: 12px 20px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
      background-color: #0064ff;
      color: #fff;
      font-weight: 600;
    }
    button:hover {
      background-color: #0052cc;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* 결과 영역 */
    #result {
      margin-top: 20px;
    }
    #submissionTime h3, #score h2 {
      margin-top: 20px;
      font-weight: 600;
      color: #212529;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background-color: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    th, td {
      text-align: center;
      padding: 12px;
      border-bottom: 1px solid #eee;
      font-size: 0.95rem;
    }
    th {
      background-color: #f1f3f5;
      font-weight: 600;
    }
    tr:last-child td {
      border-bottom: none;
    }
    .correct { color: #28a745; }
    .incorrect { color: #dc3545; }

    /* 해설 영역 */
    #explanation {
      font-size: 0.95rem;
      line-height: 1.6;
      color: #333;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    #explanation h3 {
      margin-top: 0;
      font-size: 1rem;
      font-weight: 700;
    }
    #explanation ul {
      margin-left: 1.2rem;
      margin-top: 10px;
    }
    #explanation li {
      margin-bottom: 8px;
    }

    /* 해설 다운로드 버튼 */
    #downloadExplanation {
      display: none;
      margin-top: 10px;
      padding: 10px 16px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #91a743;
      color: #fff;
      transition: background-color 0.3s;
    }
    #downloadExplanation:hover {
      background-color: #7d9435;
    }

    @media (max-width: 600px) {
      .quiz-container {
        margin: 20px auto;
        padding: 20px;
      }
      h1 {
        font-size: 1.25rem;
      }
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="quiz-container">
    <h1>네트워크 응용계층 CS 스터디 객관식 문제</h1>
    <form id="quizForm">
      <!-- 이름 입력 -->
      <label for="userName"><b>이름 입력:</b></label><br />
      <input type="text" id="userName" placeholder="이름을 입력하세요" required /><br /><br />

      <!-- 문제 영역 (문제 내용은 아래 그대로 유지) -->
      <div id="quizQuestions"></div>

      <button type="button" id="submitButton" onclick="checkAnswers()">제출하기</button>
    </form>

    <div id="result"></div>
    <div id="submissionTime"></div>
    <div id="score"></div>
    <div id="explanation"></div>
    <button type="button" id="downloadExplanation" onclick="downloadExplanation()">해설 다운로드</button>
  </div>

  <script>
    /* 
      quizData 배열은 총 20문제의 정보를 포함합니다.
      각 문제 객체는 문제(question), 옵션 배열(options), 정답(answer), 해설(explanation)을 포함합니다.
      라디오 버튼 값은 옵션 번호 ("1", "2", …)로 처리합니다.
      
      - 정답 및 해설은 제 판단으로 다음과 같이 추가하였습니다.
    */
    const quizData = [
      {
        question: "네트워크 통신에서 도메인 네임 시스템(DNS)의 효율성을 높이기 위해 사용되는 DNS 캐싱 메커니즘에 관한 설명으로, 다음 중 가장 정확한 것은?",
        options: [
          "DNS 캐싱 시스템에서는 TTL(Time to Live) 값이 만료될 때까지 캐시된 정보를 사용하며, 이 값은 해당 도메인의 소유자가 결정하는 초 단위 시간이다. TTL 값이 작을수록 DNS 변경사항이 더 빨리 전파되지만, 네임 서버의 부하는 증가한다.",
          "DNS 캐싱은 로컬 네임 서버에서만 이루어지며, 클라이언트 측에서는 어떠한 형태의 DNS 캐싱도 수행되지 않는다. TTL 값은 네트워크 관리자가 임의로 설정할 수 있어 보안상 위험요소가 될 수 있다.",
          "DNS 캐시는 영구적으로 유지되며, 새로운 DNS 정보로 명시적으로 갱신되지 않는 한 계속 사용된다. 이는 도메인 네임과 IP 주소 간의 매핑이 자주 변경되지 않는다는 가정에 기반한다.",
          "DNS 캐싱 시스템에서 TTL 값은 네트워크 패킷이 네트워크 상에서 살아있을 수 있는 최대 홉(hop) 수를 의미하며, 이 값이 0이 되면 해당 DNS 요청은 폐기된다.",
          "DNS 캐시는 호스트의 hosts 파일과 동일한 기능을 수행하며, 시스템 재부팅 시 자동으로 초기화되어 모든 DNS 레코드를 새로 획득해야 한다."
        ],
        answer: "1",
        explanation: "DNS 캐싱에서는 TTL이 캐시된 정보의 유효 기간을 결정하며, 이 값이 작으면 변경 사항이 빠르게 반영되지만 네임 서버 부하가 증가할 수 있습니다."
      },
      {
        question: "DNS 리졸빙(resolving) 과정에서 사용되는 질의 방식들에 관한 설명으로 가장 정확한 것은?",
        options: [
          "재귀적 질의(Recursive Query)에서는 클라이언트가 로컬 네임 서버에 질의하면, 로컬 네임 서버가 루트 네임 서버부터 시작하여 최종 답변을 찾을 때까지 다른 DNS 서버들에게 연속적으로 질의하고 최종 결과만을 클라이언트에게 반환한다. 이 방식은 클라이언트의 처리 부담을 줄이지만 로컬 네임 서버의 부하가 증가한다.",
          "반복적 질의(Iterative Query)에서는 클라이언트가 각 DNS 서버에 직접 순차적으로 질의하며, 최종 답변을 받을 때까지 계속해서 다른 DNS 서버들을 방문한다. 이 방식은 클라이언트의 네트워크 트래픽과 처리 부담이 크지만, 각 DNS 서버의 부하는 분산된다.",
          "재귀적 질의와 반복적 질의는 기능적으로 동일하며, 단지 질의 메시지의 포맷만 다를 뿐이다. 두 방식 모두 동일한 DNS 서버들을 통과하며 동일한 결과를 반환한다.",
          "DNS 질의 방식은 항상 재귀적 질의와 반복적 질의가 혼합된 하이브리드 방식으로 이루어지며, 이는 DNS 프로토콜에 명시된 표준 절차이다.",
          "반복적 질의에서는 로컬 네임 서버가 다른 DNS 서버에게 질의할 때마다 해당 DNS 서버는 최종 답변이 아니라 다음에 질의해야 할 DNS 서버의 주소만을 응답하고, 로컬 네임 서버는 이 과정을 반복하여 최종 결과를 얻는다."
        ],
        answer: "1",
        explanation: "DNS 리졸빙 과정에서는 주로 재귀적 질의를 사용해 로컬 네임 서버가 최종 응답을 찾아 클라이언트에 전달합니다."
      },
      {
        question: "URL(Uniform Resource Locator)의 구성 요소와 관련된 설명으로 가장 정확한 것은?",
        options: [
          "URL \"https://www.example.com:8080/path/to/resource?query=value#fragment\"에서 scheme은 'https', authority는 'www.example.com:8080', path는 '/path/to/resource', query는 '?query=value', fragment는 '#fragment'이며, authority는 호스트명과 포트번호로 구성된다.",
          "URL의 scheme 부분은 반드시 HTTP 또는 HTTPS 프로토콜만 사용할 수 있으며, 다른 프로토콜(FTP, SSH 등)은 URI 형식으로만 표현 가능하다.",
          "URL의 authority 부분은 항상 IP 주소 형태로 표현되어야 하며, 도메인 네임은 내부적으로 변환 과정을 거친 후에만 사용될 수 있다.",
          "URL의 fragment 부분은 서버로 전송되는 요청의 일부로, 서버는 이 정보를 기반으로 응답 내용을 필터링하여 반환한다.",
          "URL의 query 부분은 반드시 암호화되어 전송되어야 하며, 이는 URL의 scheme이 HTTPS일 경우에만 가능하다."
        ],
        answer: "1",
        explanation: "URL은 scheme, authority, path, query, fragment의 다섯 가지 요소로 구성되며, authority는 호스트명과 포트번호를 포함합니다."
      },
      {
        question: "HTTP 프로토콜의 특성 중 'stateless'(상태를 유지하지 않음)의 의미와 이로 인한 영향에 대한 설명으로 가장 적절한 것은?",
        options: [
          "HTTP의 stateless 특성은 서버가 이전 요청에 대한 정보나 클라이언트의 상태를 유지하지 않음을 의미한다. 이로 인해 서버의 확장성과 견고성이 향상되지만, 사용자 인증이나 세션 관리와 같은 상태 유지가 필요한 기능을 구현하기 위해서는 쿠키나 세션과 같은 추가적인 메커니즘이 필요하다.",
          "HTTP의 stateless 특성은 클라이언트가 서버의 상태 변화를 추적할 수 없음을 의미하며, 이는 서버의 보안을 강화하지만 클라이언트-서버 간 통신의 효율성을 저하시킨다.",
          "HTTP의 stateless 특성은 각 요청이 독립적으로 처리되어 이전 요청과의 연관성이 없음을 의미하며, 이로 인해 HTTP 프로토콜은 연속적인 데이터 전송이나 스트리밍 서비스에 전혀 적합하지 않다.",
          "HTTP의 stateless 특성은 서버가 모든 클라이언트의 상태를 영구적으로 저장해야 함을 의미하며, 이는 서버의 저장 공간 요구사항을 증가시키는 단점이 있다.",
          "HTTP의 stateless 특성은 각 요청이 암호화되어 상태 정보가 노출되지 않음을 의미하며, 이는 HTTPS 프로토콜에서만 적용되는 특성이다."
        ],
        answer: "1",
        explanation: "HTTP는 상태 정보를 유지하지 않으므로 확장성이 뛰어나지만, 세션 관리 등은 별도의 기법(쿠키, 세션 등)을 통해 구현해야 합니다."
      },
      {
        question: "HTTP 메서드 중 PUT과 PATCH의 차이점에 관한 설명으로 가장 정확한 것은?",
        options: [
          "PUT 메서드는 요청한 URI에 리소스를 완전히 대체(또는 생성)하는 반면, PATCH 메서드는 리소스의 일부분만을 수정한다. 따라서 PUT 요청은 리소스의 모든 필드 값을 포함해야 하지만, PATCH 요청은 변경하고자 하는 필드만 포함하면 된다.",
          "PUT 메서드는 새로운 리소스를 생성할 때만 사용되며, PATCH 메서드는 기존 리소스를 수정할 때만 사용된다. 두 메서드는 용도가 명확히 구분되어 있으며 서로 대체될 수 없다.",
          "PUT 메서드는 멱등성을 보장하지만 PATCH 메서드는 보장하지 않는다. 따라서 동일한 PUT 요청을 여러 번 보내도 결과는 항상 동일하지만, 동일한 PATCH 요청을 여러 번 보내면 결과가 달라질 수 있다.",
          "PUT 메서드는 HTTP/1.0부터 지원되었지만 PATCH 메서드는 HTTP/2.0에서 새롭게 도입되었다. 따라서 레거시 시스템에서는 PUT만 사용 가능하다.",
          "PUT 메서드는 인증된 사용자만 사용할 수 있는 반면, PATCH 메서드는 인증 없이도 사용 가능하다. 이는 PATCH가 부분 수정만 가능하기 때문에 보안 위험이 적다는 HTTP 설계 원칙에 따른 것이다."
        ],
        answer: "1",
        explanation: "PUT은 전체 리소스를 대체하거나 생성하는 데 사용되며, PATCH는 일부 필드만 변경하므로 데이터 전송량을 줄일 수 있습니다."
      },
      {
        question: "HTTP 상태 코드의 분류와 의미에 관한 설명으로 가장 정확하지 않은 것은?",
        options: [
          "100번대(정보성 상태 코드)는 요청이 수신되어 처리 중이거나 계속 진행해야 함을 나타내며, 대표적으로 100(Continue)와 101(Switching Protocols)이 있다.",
          "200번대(성공 상태 코드)는 요청이 성공적으로 처리되었음을 나타내며, 204(No Content)는 요청은 성공했지만 응답 본문에 반환할 데이터가 없음을 의미한다.",
          "300번대(리다이렉션 상태 코드)는 요청을 완료하기 위해 추가 작업이 필요함을 나타내며, 301(Moved Permanently)은 요청한 리소스가 영구적으로 새로운 위치로 이동했음을 의미한다.",
          "400번대(클라이언트 오류 상태 코드)는 요청에 오류가 있어 서버가 처리할 수 없음을 나타내며, 401(Unauthorized)은 인증이 필요하고, 403(Forbidden)은 인증은 되었으나 권한이 없음을 의미한다.",
          "500번대(서버 오류 상태 코드)는 서버가 유효한 요청을 처리하지 못했음을 나타내며, 503(Service Unavailable)은 서버가 요청을 처리할 준비가 완료되었지만 클라이언트의 접근 권한이 없음을 의미한다."
        ],
        answer: "5",
        explanation: "503 상태 코드는 서버의 과부하나 유지보수 등으로 인해 서비스가 일시적으로 중단되었음을 의미하며, 접근 권한 문제와는 관련이 없습니다."
      },
      {
        question: "HTTP 인증 과정에서 Authorization 헤더와 WWW-Authenticate 헤더의 역할에 관한 설명으로 가장 정확한 것은?",
        options: [
          "WWW-Authenticate 헤더는 서버가 401(Unauthorized) 상태 코드와 함께 클라이언트에게 보내는 것으로, 클라이언트가 자원에 접근하기 위해 어떤 인증 방식을 사용해야 하는지 알려준다. Authorization 헤더는 클라이언트가 서버에게 자신의 인증 정보를 제공하기 위해 사용하며, 일반적으로 인증 타입과 인증 정보(예: Basic 인증의 경우 Base64로 인코딩된 사용자명:비밀번호)를 포함한다.",
          "Authorization 헤더는 서버가 클라이언트에게 특정 리소스에 대한 접근 권한을 부여했음을 나타내는 응답 헤더이며, WWW-Authenticate 헤더는 클라이언트가 서버에게 인증 정보를 요청하기 위해 사용하는 요청 헤더이다.",
          "WWW-Authenticate 헤더와 Authorization 헤더는 모두 HTTP/2.0에서 새롭게 도입된 헤더로, HTTP/1.1에서는 이러한 헤더를 사용한 인증 방식이 지원되지 않는다.",
          "WWW-Authenticate 헤더는 OAuth와 같은 토큰 기반 인증에서만 사용되며, Basic 인증이나 Digest 인증에서는 사용되지 않는다. Authorization 헤더는 모든 인증 방식에서 공통적으로 사용된다.",
          "WWW-Authenticate 헤더와 Authorization 헤더는 모두 HTTPS 연결에서만 유효하며, 일반 HTTP 연결에서는 보안상의 이유로 무시된다."
        ],
        answer: "1",
        explanation: "WWW-Authenticate 헤더는 401 응답과 함께 클라이언트에 인증 방식을 지시하며, 클라이언트는 Authorization 헤더로 자신의 인증 정보를 제공합니다."
      },
      {
        question: "HTTP의 지속 연결(persistent connection)과 비지속 연결(non-persistent connection)에 관한 설명으로 가장 정확한 것은?",
        options: [
          "비지속 연결에서는 HTTP 요청-응답 쌍마다 새로운 TCP 연결을 수립하고 종료하는 반면, 지속 연결에서는 하나의 TCP 연결로 여러 요청-응답을 처리한다. HTTP/1.1부터는 기본적으로 지속 연결(Connection: keep-alive)을 사용하며, 이는 네트워크 오버헤드를 줄이고 페이지 로딩 시간을 단축시키는 장점이 있다.",
          "지속 연결은 HTTP/1.0에서만 지원되며, HTTP/1.1부터는 보안상의 이유로 모든 연결이 비지속 연결로 처리된다. 이는 각 요청마다 새로운 인증 과정을 거치도록 하여 보안을 강화하기 위함이다.",
          "지속 연결과 비지속 연결의 차이는 단순히 연결 유지 시간이며, 모든 HTTP 버전에서 기본적으로 지속 연결이 사용된다. 다만 Connection 헤더를 통해 명시적으로 연결 유지 시간을 조절할 수 있다.",
          "비지속 연결은 TCP 연결 없이 바로 HTTP 요청과 응답을 주고받는 방식이며, 지속 연결은 TCP 연결을 수립한 후 HTTP 통신을 하는 방식이다. 이는 HTTP의 기반 프로토콜 선택에 따른 차이이다.",
          "지속 연결과 비지속 연결의 선택은 전적으로 클라이언트의 선택에 달려있으며, 서버는 클라이언트의 요청에 따라 연결 방식을 변경해야 한다. 이는 HTTP 프로토콜의 클라이언트 중심 설계 원칙에 따른 것이다."
        ],
        answer: "1",
        explanation: "HTTP/1.1 이상에서는 지속 연결(keep-alive)을 기본으로 사용하여, 다수의 요청-응답을 하나의 TCP 연결에서 처리함으로써 오버헤드를 줄입니다."
      },
      {
        question: "HTTP 캐시 검증 과정에서 사용되는 '조건부 요청(conditional request)'에 관한 설명으로 가장 정확한 것은?",
        options: [
          "조건부 요청은 If-Modified-Since나 If-None-Match와 같은 헤더를 사용하여 클라이언트가 자신의 캐시가 여전히 유효한지 서버에 확인하는 방식이다. If-Modified-Since는 날짜 기반 검증으로 특정 날짜 이후에 리소스가 변경되었는지 확인하고, If-None-Match는 ETag 값을 기반으로 리소스의 변경 여부를 확인한다. 리소스가 변경되지 않았다면 서버는 304(Not Modified) 응답을 보내 클라이언트가 캐시를 재사용하도록 한다.",
          "조건부 요청은 HTTP/2.0에서 도입된 새로운 캐싱 메커니즘으로, 기존의 캐시 제어 헤더(Cache-Control, Expires 등)를 완전히 대체한다. 모든 최신 브라우저는 조건부 요청만을 사용하여 캐시 검증을 수행한다.",
          "조건부 요청은 서버가 클라이언트에게 특정 조건(예: 인증, 권한 등)을 만족할 경우에만 요청을 처리해주는 메커니즘으로, 주로 보안이 중요한 API 엔드포인트에서 사용된다.",
          "조건부 요청은 클라이언트가 서버에게 리소스의 특정 부분만 요청할 수 있는 메커니즘으로, Range 헤더와 함께 사용되어 대용량 파일의 부분 다운로드를 가능하게 한다.",
          "조건부 요청은 HTTPS에서만 유효한 메커니즘으로, 암호화된 연결에서 캐시의 안전한 재사용을 보장하기 위해 설계되었다."
        ],
        answer: "1",
        explanation: "조건부 요청은 If-Modified-Since 또는 If-None-Match 헤더를 사용해 캐시 데이터의 유효성을 확인하고, 변경이 없으면 304 상태 코드로 응답하여 캐시 재사용을 가능하게 합니다."
      },
      {
        question: "세션 인증과 쿠키의 관계 및 작동 방식에 관한 설명으로 가장 정확한 것은?",
        options: [
          "세션 인증에서 서버는 클라이언트가 제공한 인증 정보(예: 아이디, 비밀번호)를 검증한 후, 고유한 세션 ID를 생성하여 클라이언트에게 쿠키를 통해 전달한다. 서버는 이 세션 ID를 데이터베이스나 메모리에 저장하고, 클라이언트는 이후의 요청에서 쿠키에 포함된 세션 ID를 함께 전송하여 자신을 식별한다. 서버는 전송된 세션 ID를 저장된 값과 비교하여 클라이언트를 인증한다.",
          "세션 인증은 쿠키를 전혀 사용하지 않는 인증 방식으로, 모든 인증 정보는 HTTP 요청의 Authorization 헤더를 통해 매번 전송된다. 이는 쿠키의 보안 취약점을 피하기 위한 설계이다.",
          "세션 인증에서는 클라이언트가 자신의 인증 정보(아이디, 비밀번호 등)를 암호화하여 쿠키에 저장하고, 서버는 매 요청마다 이 쿠키를 복호화하여 인증을 수행한다. 이 방식은 서버에서 사용자 정보를 저장할 필요가 없어 서버 부하를 줄인다.",
          "세션 인증과 쿠키는 완전히 별개의 메커니즘으로, 세션 인증은 URL 파라미터를 통해 세션 ID를 전송하는 방식이며, 쿠키는 단순히 사용자 설정이나 선호도를 저장하는 데 사용된다.",
          "세션 인증은 클라이언트 측에서 모든 인증 로직을 처리하는 방식으로, 서버는 단지 세션 토큰이 유효한지만 확인한다. 쿠키는 이 세션 토큰을 안전하게 전송하기 위한 컨테이너 역할만 수행한다."
        ],
        answer: "1",
        explanation: "세션 인증은 서버가 세션 ID를 생성하고 이를 쿠키로 클라이언트에 전달하여, 이후 요청에서 쿠키를 통해 인증 정보를 확인하는 방식입니다."
      },
      {
        question: "URI, URL, URN의 관계 및 차이점에 관한 설명으로 가장 정확한 것은?",
        options: [
          "URI(Uniform Resource Identifier)는 인터넷 상의 자원을 식별하기 위한 통일된 방식이며, URL(Uniform Resource Locator)과 URN(Uniform Resource Name)은 URI의 하위 개념이다. URL은 자원의 위치를 기반으로 식별하는 방식(예: https://www.example.com/index.html)이고, URN은 자원의 이름을 기반으로 식별하는 방식(예: urn:isbn:0451450523)이다.",
          "URI, URL, URN은 모두 동일한 개념을 다른 맥락에서 부르는 용어이다. URI는 웹 표준에서 사용하는 공식 용어이고, URL은 브라우저 환경에서 주로 사용되며, URN은 학술적 환경에서 사용되는 용어이다.",
          "URI는 특정 프로토콜(http, https 등)에 종속적인 자원 식별자이고, URL은 프로토콜에 독립적인 위치 기반 식별자이며, URN은 특정 네임스페이스 내에서만 유효한 식별자이다.",
          "URL은 웹 브라우저에서 접근 가능한 자원을 위한 식별자이고, URN은 웹 브라우저로 직접 접근할 수 없는 자원을 위한 식별자이다. URI는 이 둘을 포괄하는 상위 개념이 아니라 URL과 URN을 조합한 하이브리드 식별자이다.",
          "URI는 HTTP 프로토콜에서만 사용되는 자원 식별자이며, URL은 모든 인터넷 프로토콜에서 사용 가능한 위치 기반 식별자이고, URN은 인트라넷 환경을 위한 전용 식별자이다."
        ],
        answer: "1",
        explanation: "URI는 자원을 식별하는 상위 개념이며, URL은 위치 기반, URN은 이름 기반 식별 방법으로 URI의 하위 개념입니다."
      },
      {
        question: "HTTP에서 미디어 타입(MIME 타입)의 역할과 구조에 관한 설명으로 가장 정확한 것은?",
        options: [
          "미디어 타입은 HTTP 메시지의 본문에 포함된 데이터의 종류를 나타내며, Content-Type 헤더를 통해 명시된다. 기본 구조는 '타입/서브타입' 형식(예: text/html, image/png, application/json)이며, 데이터를 적절하게 처리하기 위해 클라이언트와 서버 간에 데이터 형식에 대한 합의를 가능하게 한다.",
          "미디어 타입은 브라우저가 웹 페이지를 렌더링하는 방식을 결정하는 지시자로, HTML 문서의 <meta> 태그를 통해서만 지정될 수 있다. HTTP 헤더에서는 사용되지 않는다.",
          "미디어 타입은 HTTP/2.0에서 새롭게 도입된 개념으로, HTTP/1.1에서는 Content-Format 헤더를 통해 동일한 기능을 제공했다. 미디어 타입의 도입으로 인해 보다 세밀한 콘텐츠 유형 구분이 가능해졌다.",
          "미디어 타입은 서버가 클라이언트에게 전송할 수 있는 데이터 형식을 제한하는 메커니즘으로, 서버는 허용된 미디어 타입 목록을 Accept-Type 헤더를 통해 클라이언트에게 알려준다.",
          "미디어 타입은 HTTP 응답의 압축 방식을 지정하는 것으로, Content-Encoding 헤더와 함께 사용되어 데이터의 효율적인 전송을 가능하게 한다."
        ],
        answer: "1",
        explanation: "미디어 타입은 '타입/서브타입' 형식으로 HTTP Content-Type 헤더에 명시되어, 데이터의 종류를 알려줍니다."
      },
      {
        question: "도메인 네임의 계층 구조에 관한 설명으로 가장 정확한 것은?",
        options: [
          "도메인 네임은 점(.)으로 구분된 계층적 구조를 가지며, 오른쪽에서 왼쪽으로 상위 계층에서 하위 계층으로 읽는다. 예를 들어 www.example.com에서 최상위는 루트 도메인(.)이고, 다음은 최상위 도메인(TLD)인 com, 그 다음은 2단계 도메인인 example, 마지막으로 3단계 도메인(또는 호스트 네임)인 www이다.",
          "도메인 네임의 계층 구조에서는 항상 최소 4개 레벨(루트, 최상위, 2단계, 3단계)이 필요하며, 이보다 적은 레벨의 도메인 네임은 유효하지 않다.",
          "도메인 네임의 계층 구조에서 맨 왼쪽 부분이 루트 도메인이며, 오른쪽으로 갈수록 더 구체적인 하위 도메인을 나타낸다. 예를 들어 www.example.com에서 www가 최상위 도메인이다.",
          "도메인 네임의 모든 레벨은 동등한 중요성을 가지며, 계층적 구조는 단순히 가독성을 위한 것이다. DNS 시스템은 도메인 네임을 하나의 문자열로 취급한다.",
          "도메인 네임의 계층 구조는 IP 주소의 클래스(A, B, C 등) 구조와 직접적으로 대응되며, 각 도메인 레벨은 IP 주소의 특정 옥텟(8비트 단위)에 매핑된다."
        ],
        answer: "1",
        explanation: "도메인 네임은 계층적 구조로, 오른쪽(최상위)에서 왼쪽(하위)으로 읽으며 각 계층은 역할(TLD, 2단계, 3단계 등)을 가집니다."
      },
      {
        question: "로컬 호스트의 hosts 파일과 DNS 시스템의 차이점에 관한 설명으로 가장 정확한 것은?",
        options: [
          "hosts 파일은 개별 호스트에 저장된 도메인 네임과 IP 주소의 매핑 테이블로, 네트워크 요청 시 DNS 서버에 질의하기 전에 먼저 확인된다. DNS는 분산된 계층적 구조의 네임 서버들로 이루어진 글로벌 시스템으로, hosts 파일에 없는 도메인 네임을 해석하는 데 사용된다.",
          "hosts 파일은 웹 브라우저에서만 사용되는 로컬 캐시이고, DNS는 운영체제 수준에서 사용되는 네트워크 서비스이다. 따라서 브라우저 외 애플리케이션은 hosts 파일을 참조하지 않는다.",
          "hosts 파일은 네트워크 관리자에 의해 원격으로 관리되며, 네트워크 정책에 따라 자동으로 업데이트된다. DNS는 사용자가 직접 설정 가능한 로컬 서비스로, 외부 네트워크에는 영향을 주지 않는다.",
          "hosts 파일은 로컬 네트워크 내의 호스트 이름만 해석할 수 있으며, 인터넷상의 도메인은 항상 DNS를 통해서만 해석된다. 두 시스템은 완전히 독립적으로 작동한다.",
          "hosts 파일과 DNS는 동일한 기능을 하지만, hosts 파일은 IPv4만 지원하고 DNS는 IPv4와 IPv6를 모두 지원한다는 점에서 차이가 있다."
        ],
        answer: "1",
        explanation: "hosts 파일은 로컬 매핑 테이블로서 우선 조회되며, DNS는 분산된 글로벌 네임 서버를 통해 해석됩니다."
      },
      {
        question: "한 기업의 네트워크 관리자는 서비스의 가용성을 높이기 위한 방안을 고려하고 있습니다. 현재 시스템은 연간 다운타임이 8.76시간(99.9% 가용성)입니다. 이 시스템을 파이브 나인스(99.999%) 수준으로 개선하려고 합니다. 다음 중 이를 위한 접근 방식으로 가장 적절하지 않은 것은?",
        options: [
          "네트워크 인터페이스 카드를 다중화하여 단일 장애점을 제거한다.",
          "핵심 서버들을 액티브/스탠바이 구성으로 이중화한다.",
          "로드 밸런서를 도입하여 과도한 트래픽을 분산시킨다.",
          "시스템의 하드웨어 성능을 높여 처리 속도를 향상시킨다.",
          "기존 네트워크 토폴로지에서 단일 장애점을 식별하고 이를 이중화한다."
        ],
        answer: "4",
        explanation: "하드웨어 성능 향상은 처리 속도를 개선하지만, 가용성 개선에는 단일 장애점 제거와 이중화가 더 효과적입니다."
      },
      {
        question: "대규모 전자상거래 플랫폼을 운영하는 회사에서 트래픽 분산을 위한 로드 밸런싱 알고리즘을 선택해야 합니다. 다음 시나리오에 가장 적합한 로드 밸런싱 알고리즘을 고르세요.\n\n\"이 회사의 서비스는 사용자별로 세션 데이터를 저장해야 하며, 동일 사용자의 요청은 항상 같은 서버로 라우팅되어야 합니다. 또한 서버들의 성능이 다양하여 처리 능력에 차이가 있습니다.\"",
        options: [
          "단순 라운드 로빈 알고리즘",
          "최소 연결 알고리즘",
          "무작위 선택 알고리즘",
          "IP 해시 기반 알고리즘과 서버 가중치 조합",
          "응답 시간 기반 알고리즘"
        ],
        answer: "4",
        explanation: "IP 해시와 서버 가중치를 함께 적용하면 세션 지속성을 유지하면서 서버의 성능 차이도 반영할 수 있습니다."
      },
      {
        question: "한 기업의 네트워크 아키텍처를 설계하면서 프록시 서버의 도입을 고려하고 있습니다. 다음 중 포워드 프록시와 리버스 프록시의 특성과 용도에 대한 설명으로 옳지 않은 것은?",
        options: [
          "포워드 프록시는 클라이언트와 인터넷 사이에 위치하며, 클라이언트의 요청을 대신 전달하여 클라이언트의 신원을 숨길 수 있다.",
          "리버스 프록시는 인터넷과 오리진 서버 사이에 위치하며, 클라이언트의 요청을 적절한 내부 서버로 전달한다.",
          "포워드 프록시는 내부 네트워크의 콘텐츠 필터링이나 접근 제어에 활용될 수 있다.",
          "리버스 프록시는 SSL 종료, 정적 콘텐츠 캐싱, 로드 밸런싱 등의 기능을 수행할 수 있다.",
          "포워드 프록시는 오리진 서버를 보호하는 역할을 하며, 리버스 프록시는 클라이언트의 인터넷 접근을 제어하는 역할을 한다."
        ],
        answer: "5",
        explanation: "포워드 프록시는 주로 클라이언트 요청 대행 및 익명성 보장에, 리버스 프록시는 오리진 서버 보호와 부하 분산 등에 사용됩니다. 5번 설명은 두 역할을 잘못 서술했습니다."
      },
      {
        question: "다음은 암호화 관련 시나리오입니다. 가장 적절한 암호화 방식과 보안 프로토콜을 선택하세요.\n\n\"금융 서비스 회사는 고객과 서버 간 안전한 통신을 보장해야 합니다. 회사는 통신 과정에서 데이터의 무결성과 기밀성을 보장하고, 서버의 신원을 클라이언트에게 증명할 수 있어야 합니다. 또한 통신 과정은 높은 성능을 유지해야 합니다.\"",
        options: [
          "대칭키 암호화와 서버 측 인증서 없이 HTTP 프로토콜 사용",
          "비대칭키 암호화만 사용하여 모든 데이터 전송",
          "TLS 프로토콜을 사용하여 초기 핸드셰이크는 비대칭키로, 이후 데이터 전송은 협상된 대칭키로 암호화",
          "서버와 클라이언트 모두 개인키와 공개키를 교환한 후 직접 데이터 암호화",
          "해시 함수만을 사용하여 메시지의 무결성만 보장"
        ],
        answer: "3",
        explanation: "TLS 프로토콜은 초기 비대칭키 방식을 통해 보안을 설정한 후, 효율성이 높은 대칭키 암호화를 사용하여 성능과 보안을 동시에 만족시킵니다."
      },
      {
        question: "기업 네트워크의 무선 LAN에서, 모든 AP가 2.4GHz 대역의 채널 6을 사용 중일 때 일부 구역에서 연결 불안정과 속도 저하가 발생한다. 가장 적절한 해결책은?",
        options: [
          "모든 AP의 전파 출력을 최대로 설정한다.",
          "인접 AP 간에 서로 다른 채널(예: 1, 6, 11 등)을 사용하도록 재구성한다.",
          "모든 클라이언트를 최신 무선 표준으로 업그레이드한다.",
          "추가 AP를 동일 채널로 설치한다.",
          "2.4GHz 대역은 속도가 느리므로, 모든 AP를 5GHz 대역만 사용하도록 변경한다."
        ],
        answer: "2",
        explanation: "동일 채널 사용으로 인한 간섭이 주 원인입니다. 인접 AP에 대해 비간섭 채널(예: 1, 6, 11)로 재구성하는 것이 가장 적절한 해결책입니다."
      },
      {
        question: "대형 온라인 서비스 제공업체에서 99.999% 이상의 가용성을 달성하기 위한 아키텍처를 설계하고 있습니다. 다음은 이 회사의 현재 네트워크 구성에 대한 설명입니다:\n\n- 웹 서버 3대가 로드 밸런서 뒤에 위치\n- 데이터베이스 서버 1대\n- 인증 서버 1대\n- 외부 인터넷 연결 1회선\n- 무선 네트워크를 통한 내부 관리 시스템\n\n이 시스템의 결함 감내 능력을 향상시키기 위한 방안으로 우선순위가 가장 낮은 것은?",
        options: [
          "데이터베이스 서버를 마스터-슬레이브 구성으로 이중화하고, 정기적인 데이터 복제를 설정한다.",
          "인증 서버를 액티브-스탠바이 구성으로 이중화한다.",
          "별도 ISP를 통한 중복 인터넷 연결을 구성한다.",
          "무선 네트워크 AP를 이중화하고 서로 다른 채널을 사용하도록 구성한다.",
          "로드 밸런서를 이중화하고 장애 감지 및 자동 장애 조치 메커니즘을 구현한다."
        ],
        answer: "4",
        explanation: "고객에게 직접 영향을 주는 웹, DB, 인증, 인터넷 회선의 안정성 개선에 비해, 내부 관리용 무선 LAN AP의 이중화는 우선순위가 상대적으로 낮은 개선 사항입니다."
      }
    ];

    // 퀴즈 문제를 동적으로 생성하는 함수
    window.onload = function() {
      const quizDiv = document.getElementById("quizQuestions");
      let html = "";
      quizData.forEach((item, index) => {
        const qNum = index + 1;
        html += `<div class="question">${qNum}. ${item.question}</div><div class="options">`;
        item.options.forEach((option, idx) => {
          // 옵션 번호 (①, ②, ③, ④, ⑤) 생성 (idx=0 => "1", idx=1 => "2", 등)
          const optionNum = idx + 1;
          html += `<label><input type="radio" name="q${qNum}" value="${optionNum}"> ${optionNum === 1 ? "①" : 
                   optionNum === 2 ? "②" : optionNum === 3 ? "③" : optionNum === 4 ? "④" : "⑤"} ${option}</label><br>`;
        });
        html += `</div>`;
      });
      quizDiv.innerHTML = html;
    };

    // 채점 및 해설 출력 함수
    function checkAnswers() {
      const submitButton = document.getElementById("submitButton");
      if (submitButton.disabled) return;
      submitButton.disabled = true;

      const userName = document.getElementById("userName").value.trim();
      if (!userName) {
        alert("이름을 입력하세요!");
        submitButton.disabled = false;
        return;
      }

      let correctCount = 0;
      let explanationHTML = `<h3>${userName}님, 틀린 문제 해설</h3><ul>`;
      let explanationMD = `## ${userName}님, 틀린 문제 해설\n\n`;
      let resultTable = `<table>
                          <tr>
                            <th>문제 번호</th>
                            <th>제출한 답</th>
                            <th>정답</th>
                          </tr>`;

      quizData.forEach((item, index) => {
        const qNum = index + 1;
        const userAnswerElem = document.querySelector(`input[name="q${qNum}"]:checked`);
        const userAnswer = userAnswerElem ? userAnswerElem.value : "미선택";
        const correct = item.answer;
        const rowClass = (userAnswer === correct) ? "correct" : "incorrect";

        resultTable += `<tr class="${rowClass}">
                          <td>${qNum}</td>
                          <td>${userAnswer}</td>
                          <td>${correct}</td>
                        </tr>`;

        if (userAnswer === correct) {
          correctCount++;
        } else {
          explanationHTML += `<li><strong>문제 ${qNum}:</strong> ${item.explanation}</li>`;
          explanationMD += `- **문제 ${qNum}**: ${item.explanation}\n\n`;
        }
      });

      resultTable += `</table>`;
      document.getElementById("result").innerHTML = resultTable;

      const now = new Date();
      document.getElementById("submissionTime").innerHTML = `<h3>제출 시간: ${now.toLocaleTimeString()}</h3>`;
      document.getElementById("score").innerHTML = `<h2>${userName}님, 당신의 점수는 ${correctCount} / ${quizData.length}입니다.</h2>`;
      explanationHTML += "</ul>";

      if (correctCount < quizData.length) {
        document.getElementById("explanation").innerHTML = explanationHTML;
        const downloadBtn = document.getElementById("downloadExplanation");
        downloadBtn.style.display = "inline-block";
        downloadBtn.setAttribute("data-explanation", explanationMD);
      } else {
        document.getElementById("explanation").innerHTML = "<h3>모든 문제를 맞추셨습니다! 🎉</h3>";
      }
    }

    // 해설 다운로드 함수 (Markdown 파일로 저장)
    function downloadExplanation() {
      const explanationContent = document.getElementById("downloadExplanation").getAttribute("data-explanation");
      const blob = new Blob([explanationContent], { type: "text/markdown" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "네트워크_응용계층_CS_스터디_문제_틀린해설.md";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>
</body>
</html>
