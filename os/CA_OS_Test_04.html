<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>컴퓨터 구조와 운영체제 week2 01 </title>
    <!-- Google Fonts 추가 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            /* 가독성 좋은 폰트 */
            margin: 20px;
            padding: 20px;
        }

        .question {
            margin-bottom: 15px;
            font-weight: bold;
        }

        .options {
            margin-bottom: 10px;
        }

        .result {
            margin-top: 20px;
            font-weight: bold;
        }

        button {
            margin-top: 10px;
            padding: 12px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        botton:hover {
            background-color: #91a743;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            border: 1px solid black;
            text-align: center;
            padding: 12px;
        }

        .correct {
            color: green;
        }

        .incorrect {
            color: red;
        }

        /*틀린 문제 해설*/
        #explanation {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.1);
        }


        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <h1>컴퓨터구조와 운영체제 TEST 02 (25/03/06)</h1>
    <form id="quizForm">
        <!-- 이름 입력 필드 -->
        <label for="userName"><b>이름 입력:</b></label>
        <input type="text" id="userName" placeholder="이름을 입력하세요" required>
        <br><br>
        <div class="question">1. 운영체제에 대한 설명으로 적절하지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q1" value="1"> ① 운영체제는 프로그램이 실행되는 동안 필요한 자원을 할당하고 해제하는 역할을 한다.</label><br>
            <label><input type="radio" name="q1" value="2"> ② 운영체제는 사용자가 실행한 프로그램을 직접 실행하여 처리하는 역할을 한다.</label><br>
            <label><input type="radio" name="q1" value="3"> ③ 운영체제는 프로세스 관리, 메모리 관리, 파일 시스템 관리 등의 기능을 수행한다.</label><br>
            <label><input type="radio" name="q1" value="4"> ④ 운영체제는 하드웨어와 소프트웨어 사이에서 인터페이스 역할을 수행한다.</label><br>
        </div>

        <div class="question">2. 운영체제의 이중 모드와 시스템 호출에 대한 설명으로 적절하지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q2" value="1"> ① CPU는 사용자 모드와 커널 모드로 구분되며, 중요한 시스템 작업은 커널 모드에서
                실행된다.</label><br>
            <label><input type="radio" name="q2" value="2"> ② 시스템 호출을 이용하면 사용자 모드에서 실행 중인 프로그램이 운영체제의 기능을 사용할 수
                있다.</label><br>
            <label><input type="radio" name="q2" value="3"> ③ 이중 모드는 운영체제의 보안 및 안정성을 강화하는 데 기여한다.</label><br>
            <label><input type="radio" name="q2" value="4"> ④ 사용자 프로그램은 언제든지 커널 모드로 직접 전환하여 시스템 자원을 관리할 수
                있다.</label><br>
        </div>

        <div class="question">3. 다음 중 운영체제의 핵심 서비스가 아닌 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q3" value="1"> ① 프로세스 관리</label><br>
            <label><input type="radio" name="q3" value="2"> ② 자원 접근 및 할당</label><br>
            <label><input type="radio" name="q3" value="3"> ③ 사용자인터페이스 제공</label><br>
            <label><input type="radio" name="q3" value="4"> ④ 파일 시스템 관리</label><br>
        </div>

        <div class="question">4. 프로세스가 실행 중이었지만, 타이머 인터럽트로 인해 다시 준비 상태로 돌아간 경우는?</div>
        <div class="options">
            <label><input type="radio" name="q4" value="1"> ① 종료 (Terminated)</label><br>
            <label><input type="radio" name="q4" value="2"> ② 실행 (Running)</label><br>
            <label><input type="radio" name="q4" value="3"> ③ 준비 (Ready)</label><br>
            <label><input type="radio" name="q4" value="4"> ④ 대기 (Waiting)</label><br>
        </div>

        <div class="question">5. Vim 프로세스의 부모 프로세스는 무엇인가요?</div>
        <div class="options">
            <label><input type="radio" name="q5" value="1"> ① 로그인 프로세스</label><br>
            <label><input type="radio" name="q5" value="2"> ② bash 프로세스</label><br>
            <label><input type="radio" name="q5" value="3"> ③ init 프로세스</label><br>
            <label><input type="radio" name="q5" value="4"> ④ 커널</label><br>
        </div>

        <!-- 나머지 문제 (6~20번) 동일한 패턴으로 추가 -->

        <div class="question">6. fork와 exec에 대한 설명으로 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q6" value="1"> ① fork 시스템 호출을 하면 새로운 프로세스가 생성된다.</label><br>
            <label><input type="radio" name="q6" value="2"> ② fork 시스템 호출을 하면 부모 프로세스의 복제본이 자식 프로세스로서 생성된다.</label><br>
            <label><input type="radio" name="q6" value="3"> ③ exec 시스템 호출을 하면 프로세스의 메모리 공간이 다른 프로세스의 내용으로
                변경된다.</label><br>
            <label><input type="radio" name="q6" value="4"> ④ exec 시스템 호출을 하면 새로운 프로세스가 생성된다.</label><br>
        </div>

        <div class="question">7. 프로세스 상태에 대한 설명으로 옳은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q7" value="1"> ① 생성 상태는 프로세스가 입출력 장치의 작업을 기다리는 상태이다.</label><br>
            <label><input type="radio" name="q7" value="2"> ② 실행 상태는 프로세스가 종료되는 상태이다.</label><br>
            <label><input type="radio" name="q7" value="3"> ③ 종료 상태는 프로세스가 이제 막 생성된 상태이다.</label><br>
            <label><input type="radio" name="q7" value="4"> ④ 준비 상태는 CPU를 할당받기를 기다리고 있는 상태이다.</label><br>
        </div>

        <div class="question">8. 스레드에 대한 설명으로 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q8" value="1"> ① 스레드는 프로세스 내의 실행 흐름 단위이다.</label><br>
            <label><input type="radio" name="q8" value="2"> ② 프로세스 내의 스레드들은 각기 다른 코드/데이터/힙 영역을 가지고 있다.</label><br>
            <label><input type="radio" name="q8" value="3"> ③ 프로세스 내의 스레드들은 각각 다른 프로그램 카운터를 가지고 있다.</label><br>
            <label><input type="radio" name="q8" value="4"> ④ 프로세스 내의 스레드들은 각기 다른 스택을 가지고 있다.</label><br>
        </div>

        <div class="question">9. 멀티프로세스와 멀티스레드의 차이에 대한 설명으로 옳은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q9" value="1"> ① 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 프로세스 내의 스레드는 같은 자원을
                공유한다.</label><br>
            <label><input type="radio" name="q9" value="2"> ② 프로세스는 자원을 공유하지만, 스레드는 자원을 공유하지 않는다.</label><br>
            <label><input type="radio" name="q9" value="3"> ③ 멀티프로세스 환경에서는 프로세스 간 데이터를 공유하기 위해 스레드가 필요하다.</label><br>
            <label><input type="radio" name="q9" value="4"> ④ 멀티스레드는 프로세스 간 통신(IPC)을 필요로 한다.</label><br>
        </div>

        <div class="question">10. 프로세스 스케줄링에 대해 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q10" value="1"> ① 운영체제는 우선순위를 토대로 프로세스를 스케줄링한다.</label><br>
            <label><input type="radio" name="q10" value="2"> ② 프로세스는 스케줄링 큐를 사용하여 스케줄링된 프로세스를 관리한다.</label><br>
            <label><input type="radio" name="q10" value="3"> ③ 준비 큐에는 준비 상태인 프로세스가, 대기 큐에는 대기 상태인 프로세스가
                삽입된다.</label><br>
            <label><input type="radio" name="q10" value="4"> ④ 선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 없는 방식을 의미한다.</label><br>
        </div>

        <div class="question">11. 선점형 스케줄링과 비선점형 스케줄링에 대한 설명 중 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q11" value="1"> ① 선점형 스케줄링은 어느 한 프로세스가 자원을 독점할 수 없는 스케줄링 방식이다.</label><br>
            <label><input type="radio" name="q11" value="2"> ② 선점형 스케줄링은 문맥 교환 과정의 오버헤드가 비선점형 스케줄링에 비해 적다.</label><br>
            <label><input type="radio" name="q11" value="3"> ③ 비선점형 스케줄링은 어느 한 프로세스가 자원을 독점할 수 있는 스케줄링 방식이다.</label><br>
            <label><input type="radio" name="q11" value="4"> ④ 비선점형 스케줄링은 문맥 교환 과정의 오버헤드가 선점형 스케줄링에 비해 적다.</label><br>
        </div>

        <div class="question">12. 준비 큐에 프로세스 A, B, C, D 순으로 삽입되었다고 가정했을 때, 선입 선처리 스케줄링 알고리즘을 적용하면 어떤 프로세스 순서대로 CPU를 할당받게
            될까요?</div>
        <div class="options">
            <label><input type="radio" name="q12" value="1"> ① A - D - B - C</label><br>
            <label><input type="radio" name="q12" value="2"> ② B - C - A - D</label><br>
            <label><input type="radio" name="q12" value="3"> ③ A - B - C - D</label><br>
            <label><input type="radio" name="q12" value="4"> ④ D - C - B - A</label><br>
        </div>

        <div class="question">13. 우선순위 스케줄링 알고리즘을 적용하면, 어떤 프로세스가 먼저 CPU를 할당받을까요?</div>
        <div class="options">
            <label><input type="radio" name="q13" value="1"> ① 가장 늦게 삽입된 프로세스</label><br>
            <label><input type="radio" name="q13" value="2"> ② 가장 높은 우선순위를 가진 프로세스</label><br>
            <label><input type="radio" name="q13" value="3"> ③ 가장 낮은 우선순위를 가진 프로세스</label><br>
            <label><input type="radio" name="q13" value="4"> ④ 가장 긴 실행 시간을 가진 프로세스</label><br>
        </div>

        <div class="question">14. 라운드 로빈(Round Robin) 스케줄링 방식에 대한 설명으로 옳은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q14" value="1"> ① 우선순위가 높은 프로세스가 CPU를 독점한다.</label><br>
            <label><input type="radio" name="q14" value="2"> ② 프로세스가 할당된 시간(Time Quantum) 동안 실행된 후 준비 큐의 마지막으로
                이동한다.</label><br>
            <label><input type="radio" name="q14" value="3"> ③ 실행 시간이 긴 프로세스가 우선적으로 CPU를 배정받는다.</label><br>
            <label><input type="radio" name="q14" value="4"> ④ 입출력 작업을 수행하는 프로세스가 항상 먼저 실행된다.</label><br>
        </div>

        <div class="question">15. 멀티프로세스와 멀티스레드에 대한 설명으로 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q15" value="1"> ① 멀티프로세스는 각 프로세스가 독립적인 메모리 공간을 사용한다.</label><br>
            <label><input type="radio" name="q15" value="2"> ② 멀티스레드는 프로세스 내의 모든 스레드가 동일한 데이터와 힙 영역을 공유한다.</label><br>
            <label><input type="radio" name="q15" value="3"> ③ 멀티스레드는 문맥 교환(Context Switch) 비용이 멀티프로세스보다 크다.</label><br>
            <label><input type="radio" name="q15" value="4"> ④ 멀티프로세스 환경에서는 프로세스 간 데이터 공유를 위해 IPC(Inter-Process
                Communication)가 필요하다.</label><br>
        </div>

        <div class="question">16. 멀티프로세스 환경에서 프로세스 간 통신(IPC, Inter-Process Communication) 기법으로 사용되지 않는 것은?</div>
        <div class="options">
            <label><input type="radio" name="q16" value="1"> ① 공유 메모리(Shared Memory)</label><br>
            <label><input type="radio" name="q16" value="2"> ② 메시지 큐(Message Queue)</label><br>
            <label><input type="radio" name="q16" value="3"> ③ 세마포어(Semaphore)</label><br>
            <label><input type="radio" name="q16" value="4"> ④ 스택(Stack)</label><br>
        </div>

        <div class="question">17. 스레드의 특징에 대한 설명으로 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q17" value="1"> ① 스레드는 같은 프로세스 내에서 실행되며, 코드/데이터/힙 영역을 공유한다.</label><br>
            <label><input type="radio" name="q17" value="2"> ② 모든 스레드는 독립적인 프로그램 카운터(PC)와 레지스터, 스택을 가진다.</label><br>
            <label><input type="radio" name="q17" value="3"> ③ 하나의 스레드가 오류를 일으키면 같은 프로세스 내의 다른 스레드에는 영향을 주지
                않는다.</label><br>
            <label><input type="radio" name="q17" value="4"> ④ 스레드는 멀티스레딩 환경에서 실행될 경우 성능을 향상시킬 수 있다.</label><br>
        </div>

        <div class="question">18. 스레드의 실행 방식 중 커널 수준 스레드(Kernel-Level Thread, KLT) 와 사용자 수준 스레드(User-Level Thread, ULT)
            의 차이점에 대한 설명으로 옳지 않은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q18" value="1"> ① 커널 수준 스레드는 운영체제가 직접 관리하며, 시스템 호출을 통해 스레드 스케줄링이
                이루어진다.</label><br>
            <label><input type="radio" name="q18" value="2"> ② 사용자 수준 스레드는 운영체제의 개입 없이 사용자 공간에서 스레드 관리를
                수행한다.</label><br>
            <label><input type="radio" name="q18" value="3"> ③ 커널 수준 스레드는 운영체제의 지원을 받기 때문에 사용자 수준 스레드보다 오버헤드가
                낮다.</label><br>
            <label><input type="radio" name="q18" value="4"> ④ 사용자 수준 스레드는 커널에 의존하지 않으므로 문맥 교환이 빠르다.</label><br>
        </div>


        <div class="question">19. 멀티스레딩(Multithreading) 환경에서 발생할 수 있는 문제에 대한 설명으로 옳은 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q19" value="1"> ① 멀티스레딩 환경에서는 여러 스레드가 동일한 데이터에 접근해도 충돌이 발생하지
                않는다.</label><br>
            <label><input type="radio" name="q19" value="2"> ② 스레드 간 공유 자원 사용 시 상호 배제(Mutual Exclusion) 가
                필요하다.</label><br>
            <label><input type="radio" name="q19" value="3"> ③ 멀티스레딩 환경에서는 항상 성능이 향상되므로 동기화 기법이 필요하지 않다.</label><br>
            <label><input type="radio" name="q19" value="4"> ④ 멀티스레드 환경에서는 프로세스 간 데이터 공유보다 더 많은 메모리를 필요로 한다.</label><br>
        </div>

        <div class="question">20. 다음 중 멀티스레딩을 사용하는 이유로 가장 적절한 것을 고르시오.</div>
        <div class="options">
            <label><input type="radio" name="q20" value="1"> ① 문맥 교환(Context Switch) 비용을 증가시키기 위해</label><br>
            <label><input type="radio" name="q20" value="2"> ② CPU 활용도를 높이고 응답성을 개선하기 위해</label><br>
            <label><input type="radio" name="q20" value="3"> ③ 프로세스 간의 독립적인 실행을 보장하기 위해</label><br>
            <label><input type="radio" name="q20" value="4"> ④ 멀티스레딩 환경에서는 동기화가 필요하지 않기 때문에</label><br>
        </div>



        <button type="button" id="submitButton" onclick="checkAnswers()">
            제출하기
        </button>
        <div id="submissionTime" style="margin-top: 10px"></div>
    </form>

    <div id="result"></div>
    <div id="score"></div>
    <div id="explanation"></div>

    <!-- 해설 다운로드 버튼 -->
    <button type="button" id="downloadExplanation" style="display: none;" onclick="downloadExplanation()">해설
        다운로드</button>

    <script>
        function checkAnswers() {
            let submitButton = document.getElementById("submitButton");
            if (submitButton.disabled) return;
            submitButton.disabled = true;
            submitButton.style.cursor = "not-allowed";

            let userName = document.getElementById("userName").value.trim();
            if (userName === "") {
                alert("이름을 입력하세요!");
                submitButton.disabled = false;
                submitButton.style.cursor = "pointer";
                return;
            }

            let answers = {
                "q1": 2, "q2": 4, "q3": 3, "q4": 3, "q5": 2,
                "q6": 4, "q7": 4, "q8": 2, "q9": 1, "q10": 4,
                "q11": 2, "q12": 3, "q13": 2, "q14": 2, "q15": 3,
                "q16": 4, "q17": 3, "q18": 3, "q19": 2, "q20": 2
            };


            let explanations = {
                "q1": "정답: ② 운영체제는 사용자가 실행한 프로그램을 직접 실행하지 않습니다. 운영체제는 프로그램이 실행될 수 있도록 환경을 제공하고, 프로세스를 관리하며, 필요한 자원을 할당하는 역할을 합니다. 프로그램의 실제 실행은 CPU에서 이루어지며, 운영체제는 이를 관리하는 역할을 합니다.",
                "q2": "정답: ④ 사용자 프로그램은 직접 커널 모드로 전환할 수 없으며, 반드시 시스템 호출(System Call)을 통해야 합니다. 운영체제는 보안과 안정성을 위해 커널 모드에서만 시스템 자원을 관리하며, 직접 전환이 불가능하도록 설계되어 있습니다.",
                "q3": "정답: ③ 운영체제는 프로세스 관리, 자원 관리, 파일 시스템 관리, 메모리 관리, 장치 관리 등의 핵심 서비스를 제공합니다. 하지만 사용자 인터페이스(UI) 제공은 운영체제의 필수 기능이 아닙니다. UI는 운영체제와 함께 제공될 수도 있지만, 반드시 운영체제의 핵심 역할로 포함되지는 않습니다.",
                "q4": "정답: ③ 프로세스가 실행 중일 때, 타이머 인터럽트가 발생하면 CPU를 다른 프로세스에 넘겨주고 준비(Ready) 상태로 돌아갑니다. 이는 선점형 스케줄링에서 흔히 발생하는 동작이며, 운영체제가 효율적으로 여러 프로세스를 관리하는 데 중요한 개념입니다.",
                "q5": "정답: ② Vim 프로세스의 부모 프로세스는 bash 프로세스입니다. 운영체제에서 하나의 프로세스가 다른 프로세스를 생성하면, 생성된 프로세스는 자식 프로세스, 생성한 프로세스는 부모 프로세스가 됩니다. 로그인 프로세스가 bash를 실행하면 bash의 부모는 로그인 프로세스이고, bash가 Vim을 실행하면 Vim의 부모는 bash 프로세스가 됩니다.",
                "q6": "정답: ④ exec() 시스템 호출은 새로운 프로세스를 생성하지 않습니다. fork() 시스템 호출을 하면 부모 프로세스의 복제본이 생성되며, 이를 자식 프로세스라고 합니다. exec() 시스템 호출을 하면 기존 프로세스의 메모리 공간이 새로운 프로그램으로 덮어씌워지지만, 새로운 프로세스를 생성하는 것은 아닙니다.",
                "q7": "정답: ④ 준비(Ready) 상태는 CPU를 할당받기를 기다리는 상태입니다. 프로세스는 생성되면 준비 상태로 들어가고, 실행 중 인터럽트가 발생하면 다시 준비 상태로 돌아갑니다. 실행(Running) 상태는 프로세스가 실제로 실행되는 상태이며, 종료(Terminated) 상태는 실행이 완료된 상태입니다.",
                "q8": "정답: ② 스레드는 같은 프로세스 내에서 코드, 데이터, 힙을 공유합니다. 다만, 각각의 스레드는 독립적인 프로그램 카운터(PC)와 스택(Stack)을 가집니다. 프로세스 내의 스레드들은 서로 같은 메모리 공간을 공유하므로, 상호 배제(Mutex)나 동기화(Synchronization) 기법이 필요할 수 있습니다.",
                "q9": "정답: ① 멀티프로세스는 프로세스 간에 독립적인 메모리 공간을 가지며, 기본적으로 자원을 공유하지 않습니다. 반면, 멀티스레드는 같은 프로세스 내에서 동작하며, 같은 메모리 공간(코드, 데이터, 힙)을 공유합니다. 따라서 '공유하지 않지만 / 공유합니다'가 올바른 정답입니다.",
                "q10": "정답: ④ 선점형 스케줄링에서는 프로세스의 자원을 빼앗을 수 있습니다. 선점형 스케줄링은 운영체제가 CPU를 할당한 프로세스를 강제로 중단시키고 다른 프로세스에 CPU를 할당할 수 있는 방식입니다. 반대로 비선점형 스케줄링에서는 프로세스가 CPU를 할당받으면 해당 프로세스가 종료되거나 대기 상태로 변경될 때까지 강제로 중단되지 않습니다.",
                "q11": "정답: ② 선점형 스케줄링은 문맥 교환(context switch) 과정이 빈번하게 발생하여 오버헤드가 커집니다. 반면, 비선점형 스케줄링에서는 문맥 교환이 적게 발생하므로 오버헤드가 상대적으로 적습니다.",
                "q12": "정답: ③ 선입 선처리(FCFS, First Come First Served) 스케줄링은 준비 큐에 먼저 들어온 순서대로 CPU를 할당하는 방식입니다. 따라서 A → B → C → D 순서대로 CPU를 할당받게 됩니다. FCFS 스케줄링은 공정하지만, 실행 시간이 긴 프로세스가 앞에 오면 대기 시간이 길어지는 단점이 있습니다.",
                "q13": "정답: ② 우선순위 스케줄링은 우선순위(priority)가 높은 프로세스가 먼저 CPU를 할당받는 방식입니다. 만약 우선순위가 낮은 프로세스가 계속해서 실행되지 못하는 경우, 이를 기아 현상(Starvation) 이라고 하며, 이를 방지하기 위해 에이징(Aging) 기법을 사용할 수 있습니다.",
                "q14": "정답: ② 라운드 로빈(RR) 스케줄링은 각 프로세스가 정해진 시간(Time Quantum)만큼 실행된 후, 준비 큐의 마지막으로 이동하는 방식입니다. CPU 시간을 공평하게 분배하는 특징이 있으며, 인터랙티브 시스템에서 많이 사용됩니다.",
                "q15": "정답: ③ 멀티스레드는 문맥 교환 비용이 멀티프로세스보다 작습니다. 멀티프로세스 환경에서는 각 프로세스가 독립적인 메모리 공간을 사용하지만, 멀티스레드는 프로세스 내에서 자원을 공유하므로 문맥 교환 비용이 절감됩니다.",
                "q16": "정답: ④ 스택(Stack)은 IPC(프로세스 간 통신) 기법으로 사용되지 않습니다. IPC 기법에는 공유 메모리(Shared Memory), 메시지 큐(Message Queue), 세마포어(Semaphore) 등이 있습니다.",
                "q17": "정답: ③ 하나의 스레드가 오류를 일으키면 같은 프로세스 내 다른 스레드에도 영향을 줍니다. 예를 들어, 하나의 스레드가 비정상 종료되면 전체 프로세스가 종료될 수 있습니다.",
                "q18": "정답: ③ 커널 수준 스레드는 운영체제가 직접 관리하며, 문맥 교환이 발생할 때 커널의 개입이 필요하여 오버헤드가 증가할 수 있습니다. 사용자 수준 스레드는 운영체제가 개입하지 않고 사용자 공간에서 관리되므로 문맥 교환 비용이 낮고 속도가 빠릅니다.",
                "q19": "정답: ② 멀티스레딩 환경에서는 여러 스레드가 동일한 데이터에 접근할 수 있어 충돌(경쟁 상태, Race Condition)이 발생할 수 있습니다. 이를 방지하기 위해 상호 배제(Mutual Exclusion, Mutex)와 같은 동기화 기법이 필요합니다.",
                "q20": "정답: ② 멀티스레딩의 주요 목적은 CPU 활용도를 높이고, 사용자 응답성을 개선하는 것입니다. 멀티스레딩을 사용하면 여러 작업을 병렬로 수행할 수 있으며, 대기 시간이 줄어듭니다."
            };

            let now = new Date();
            let timeString = now.toLocaleTimeString();
            document.getElementById("submissionTime").innerText = `제출 시간: ${timeString}`;
            
            let correctCount = 0;
            let incorrectExplanations = "";
            let explanationText = `<h3>${userName}님, 틀린 문제 해설</h3><ul>`;

            let resultTable = `<table>
                    <tr>
                        <th>문제 번호</th>
                        <th>제출한 답</th>
                        <th>정답</th>
                    </tr>`;

            for (let key in answers) {
                let userAnswer = document.querySelector(`input[name="${key}"]:checked`);
                let userAnswerValue = userAnswer ? userAnswer.value : "미선택";
                let rowClass = userAnswerValue === String(answers[key]) ? "correct" : "incorrect";

                resultTable += `<tr class="${rowClass}">
                        <td>${key.replace("q", "")}</td>
                        <td>${userAnswerValue}</td>
                        <td>${answers[key]}</td>
                    </tr>`;

                if (userAnswerValue === String(answers[key])) {
                    correctCount++;
                } else {
                    explanationText += `<li>${explanations[key]}</li>`;
                    incorrectExplanations += `문제 ${key.replace("q", "")}: ${explanations[key]}\n\n`;
                }
            }

            resultTable += `</table>`;

            document.getElementById("result").innerHTML = resultTable;
            document.getElementById("score").innerHTML = `<h2>${userName}님, 당신의 점수는 ${correctCount} / 20입니다.</h2>`;

            explanationText += "</ul>";
            document.getElementById("explanation").innerHTML = incorrectExplanations ? explanationText : "<h3>모든 문제를 맞췄습니다! 🎉</h3>";

            // 해설 다운로드 버튼 표시
            if (incorrectExplanations.trim() !== "") {
                document.getElementById("downloadExplanation").style.display = "block";
                document.getElementById("downloadExplanation").setAttribute("data-explanation", incorrectExplanations);
            }
        }

        function downloadExplanation() {
            let explanationContent = document.getElementById("downloadExplanation").getAttribute("data-explanation");
            let blob = new Blob([explanationContent], { type: "text/plain" });
            let link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "틀린 문제 해설.txt";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>


</body>

</html>
